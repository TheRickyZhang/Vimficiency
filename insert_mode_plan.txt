Fundamentally, operations in insert mode can be boiled down to a consecutive sequence of diffs. Let's work with the following conversion:

0123456789ab
I like cats
You like dogs.
0  123456789a b
0123456789abcd

The edit sequences in order are:
I -> You : [0, 1) -> [0, 2]
cats -> dogs. : [7, b) -> [9, d]

In each edit sequence, we want to calculate the cheapest cost to do the edit, for every single start-end combination. Here is an example with cats->dogs:
If we start at 7, and do: cwdogs.<Esc>, we end at d. So best[7][d] = cost(cwdogs<Esc>).
If we start at 8, and do: ciwdogs.<Esc>, we end at d, (best[8][d]). 
If we start at a, and do: a.<Esc>hrghrohrd, we end at 9, (best[a][9]). 

This involves a multi-source A* search from all starting positions, which include an expanded search state for edit operations / insert mode transitions. Some start-end combinations might be difficult to reach, so we can limit the search to only find results cheaper than the best result + some constant. 

We only need to consider positions where col == targetCol, as pretty much all edit motions reset targetCol to col.

Our new heuristic for distance to goal will be based on Levenshtein distance for the concatenated current/end states, including new lines characters. Since the end string is fixed, we can cache prefixes from the current string, which will hopefully work well because with our optimization goal, most later candidate states will have the same prefix changes as earlier explored ones. We estimate amortized that distance is O(n) per state.

The search space is O(n^2), so our overall complexity estimate is O(n^3) with high constant factor, which I estimate is safe for n <= 50.

But we will need to benchmark this later, especially as an optimize() involves multiple edit pre computations.


I am a bit unsure with whether to include boundaries, though. For instance, if I had:
dog cat -> cat cat:
It is possible to do cb from the space to start editing, which is outside the exact diff range, but works because of start/end correspondence (w b). Is including one past the end like this enough, or are there other cases I am missing, that might make this too complex to handle?
I think for now, let's stick with [start, end). Since adjacent edits would have been combined, we still guarantee our edit sequences are disjoint.

So now, in our optimizer, we can think of possible edits as a special type of normal motion. We store parameter editsMade in each state, and pass the correct lines corresponding to how many edits were made, so that motions apply correctly. WLOG suppose we are making progress forward (for backwards, we simply reverse).

If a state has a position inside an edit range, it has the option to explore all precomputed best sequences. Our distance function now includes the number of edit sequences left, weighted heavily to narrow down on finding an exact solution, and we apply a heavy penalty to any states with position > last completed / currently exploring state, as that means we have "overshot" our edit, which is unoptimal for doing the edits in order.

It is also tricky how to ensure position alignment. We can assume that all edits must happen in order; I think since we are updating which "version" of lines we are at depending on editsMade, we can ensure our positions are always correct for that state, and so we can know the corresponding range.
