- Currently the model can only recommend back default vim bindings, regardless of user mappings. It seems feasible that the user can provide some mappings, and we can adjust the cost model.

- To keep the search quick, we store a minimal state only consisting of a snapshot of contiguous lines and a (row, col) position. 

This means we cannot support the following operations:
- gj, gk, H, M, L, zz (screen-related)
- Cross-jumps

TODO fixes:
e0lk is returned on uniform.txt (0, 0) -> (2, 1), when it clearly should not.

TODO features:
Pass in screen height by lines to properly use <C-d>, <C-u>, etc. 

Maybe:
minimal register/macro use. Can't ingest current registers, but can process with some default register (ex a) if detecting repetition in search.


It is pretty dumb how nvim_win_get_cursor returns a 1-indexed row, while buf_get_lines and the natural internal representation has a 0-indexed row. I will choose the correct representation (0-indexed), and shouldn't be an issue apart from direct line jumps (:36).

LuaJIT's FFI only targets the C ABI, as native C++ ABI is pretty difficult (would need to consider all the added features / stdlib / object layout)

Interesting (maybe?) things that have come up:
- C ABI
- C++ Name Mangling
- X Macros. May become obsolete with reflection in C++ 26?
- std::streambuf, and cout.rdbuf as getter/setter
- CMake visibility: public, private, interface
- When you need same type of space per many function calls, static declaration has downsides over stack: not safe to recursion, worse cache behavior. 
- Map<T> uses std::less<T> as the comparator by default, which can only take in T. But if we pass std::less<>, which is "transparent", now we can have anything comparable to T, like string vs string_view.
- You can't store references in initializer list, but can use a reference wrapper (basically use * as underlying, with & interface) to get around.
- Difference in the way types are returned depending on if simple and <= 16 bytes: use register vs pass hidden pointer
- Use a hash function to change long if/else chain to switch case
- You can use iterator construction for anything as long as value_type convertible to T
- You need extra {} scope in switch statement to not leak definitions (at underlying jump table, they are not separate blocks)
