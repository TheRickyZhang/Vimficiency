Supporting operator motions:

3) Blueprint comments for dip, vap, etc.

You’ll eventually want to separate “cursor motion” from “operator application”.

A) Parse structure: [count] [operator?] [motion | textobj]

Examples:

{ / }: just a motion (moves cursor)

d}: operator d + motion }

dip: operator d + text object ip

vap: operator v (visual) + text object ap (or: enter visual, then expand selection)

A clean approach is to parse into something like:

struct Command {
  int count = 1;
  char op = 0;          // 'd','y','c' etc; 0 means "no operator"
  bool isTextObj = false;
  std::string motionOrObj; // "w", "}", "ip", "ap", ...
};

B) Normalize everything into a range

For operator commands, compute a range in buffer coordinates and pass it to the operator:

struct Range { Position a, b; bool inclusive; }; // define your exact convention


Motions produce a destination position dst → range is [pos..dst] (with Vim-like inclusive/exclusive rules you choose).

Text objects produce a range directly (paragraph bounds, word bounds, inside braces, etc.).

C) Implement paragraph text objects once, reuse everywhere

Core helper:

// around=false => "inner paragraph" (ip)
// around=true  => "around paragraph" (ap)
Range paragraphObjectRange(Position cur, lines, bool around);


Suggested simplified semantics:

Find the non-blank paragraph containing (or nearest to) cur.

If on blank lines, decide: either pick the next non-blank paragraph (common UX), or treat blank-run as its own object.

For ip: select only the non-blank lines of that paragraph (exclude surrounding blank lines).

For ap: include one adjacent blank-line run (typically trailing blank line(s); Vim has nuanced rules, but you can start simpler).

D) Apply operator to that range

Pseudo-flow:

if(cmd.op == 0) {
  // pure motion: move cursor
  pos = apply_motion(pos, mode, cmd.motionOrObj, lines).pos;
} else {
  Range rg;
  if(cmd.isTextObj) rg = computeTextObjRange(pos, cmd.motionOrObj, lines);
  else {
    Position dst = apply_motion(pos, mode, cmd.motionOrObj, lines).pos;
    rg = rangeFromMotion(pos, dst, /*inclusive rules*/);
  }
  applyOperator(cmd.op, rg, /*buffer*/);
}


Operators:

d delete range, keep cursor at start of deleted region

y yank range to register, cursor usually stays

c change = delete then enter insert mode









